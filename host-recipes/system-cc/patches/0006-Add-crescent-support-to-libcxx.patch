From 7ee50271aac99178ab2c0069850f0f34fdaa1566 Mon Sep 17 00:00:00 2001
From: Qwinci <32550582+Qwinci@users.noreply.github.com>
Date: Mon, 25 Nov 2024 18:06:08 +0200
Subject: [PATCH 6/6] Add crescent support to libcxx

---
 libcxx/include/CMakeLists.txt                 |   1 +
 libcxx/include/__config                       |   2 +
 libcxx/include/__config_site.in               |   2 +-
 libcxx/include/__cxx03/__config               |   2 +
 libcxx/include/__locale                       |  16 +-
 libcxx/include/__locale_dir/locale_base_api.h |  87 ++++--
 .../__locale_dir/locale_base_api/crescent.h   | 169 +++++++++++
 libcxx/include/__locale_dir/locale_guard.h    |   6 +
 libcxx/include/fstream                        |   6 +-
 libcxx/include/print                          |   3 +
 libcxx/src/CMakeLists.txt                     |   6 +
 libcxx/src/chrono.cpp                         |  18 ++
 libcxx/src/experimental/tzdb.cpp              |   2 +-
 libcxx/src/filesystem/file_descriptor.h       |   1 +
 libcxx/src/filesystem/filesystem_clock.cpp    |   3 +
 libcxx/src/filesystem/posix_compat.h          |   3 +
 libcxx/src/filesystem/time_utils.h            |   3 +
 libcxx/src/include/config_elast.h             |   2 +
 libcxx/src/locale.cpp                         |   8 +-
 libcxx/src/random.cpp                         |  12 +
 .../src/support/crescent/locale_crescent.cpp  | 275 ++++++++++++++++++
 libcxx/src/support/crescent/support.cpp       | 190 ++++++++++++
 libcxx/src/system_error.cpp                   |   5 +
 23 files changed, 794 insertions(+), 28 deletions(-)
 create mode 100644 libcxx/include/__locale_dir/locale_base_api/crescent.h
 create mode 100644 libcxx/src/support/crescent/locale_crescent.cpp
 create mode 100644 libcxx/src/support/crescent/support.cpp

diff --git a/libcxx/include/CMakeLists.txt b/libcxx/include/CMakeLists.txt
index 83168d153a..bcc89afe9c 100644
--- a/libcxx/include/CMakeLists.txt
+++ b/libcxx/include/CMakeLists.txt
@@ -497,6 +497,7 @@ set(files
   __locale_dir/locale_base_api/android.h
   __locale_dir/locale_base_api/bsd_locale_defaults.h
   __locale_dir/locale_base_api/bsd_locale_fallbacks.h
+  __locale_dir/locale_base_api/crescent.h
   __locale_dir/locale_base_api/fuchsia.h
   __locale_dir/locale_base_api/ibm.h
   __locale_dir/locale_base_api/musl.h
diff --git a/libcxx/include/__config b/libcxx/include/__config
index 9db00cd0c9..73acdd2549 100644
--- a/libcxx/include/__config
+++ b/libcxx/include/__config
@@ -829,6 +829,8 @@ typedef __char32_t char32_t;
 // TODO(44575): Switch to C11 thread API when possible.
 #      undef _LIBCPP_HAS_THREAD_API_PTHREAD
 #      define _LIBCPP_HAS_THREAD_API_PTHREAD 1
+#    elif defined(__crescent__)
+#      define _LIBCPP_HAS_THREAD_API_C11 1
 #    elif defined(_LIBCPP_WIN32API)
 #      undef _LIBCPP_HAS_THREAD_API_WIN32
 #      define _LIBCPP_HAS_THREAD_API_WIN32 1
diff --git a/libcxx/include/__config_site.in b/libcxx/include/__config_site.in
index fc01aaf2d8..527d4be984 100644
--- a/libcxx/include/__config_site.in
+++ b/libcxx/include/__config_site.in
@@ -20,7 +20,7 @@
 #cmakedefine01 _LIBCPP_HAS_THREAD_API_PTHREAD
 #cmakedefine01 _LIBCPP_HAS_THREAD_API_EXTERNAL
 #cmakedefine01 _LIBCPP_HAS_THREAD_API_WIN32
-#define _LIBCPP_HAS_THREAD_API_C11 0 // FIXME: Is this guarding dead code?
+//#define _LIBCPP_HAS_THREAD_API_C11 0 // FIXME: Is this guarding dead code?
 #cmakedefine _LIBCPP_DISABLE_VISIBILITY_ANNOTATIONS
 #cmakedefine01 _LIBCPP_HAS_VENDOR_AVAILABILITY_ANNOTATIONS
 #cmakedefine _LIBCPP_NO_VCRUNTIME
diff --git a/libcxx/include/__cxx03/__config b/libcxx/include/__cxx03/__config
index 6f77292387..83520bd92f 100644
--- a/libcxx/include/__cxx03/__config
+++ b/libcxx/include/__cxx03/__config
@@ -823,6 +823,8 @@ typedef __char32_t char32_t;
 #    elif defined(__Fuchsia__)
 // TODO(44575): Switch to C11 thread API when possible.
 #      define _LIBCPP_HAS_THREAD_API_PTHREAD
+#    elif defined(__crescent__)
+#      define _LIBCPP_HAS_THREAD_API_C11 1
 #    elif defined(_LIBCPP_WIN32API)
 #      define _LIBCPP_HAS_THREAD_API_WIN32
 #    else
diff --git a/libcxx/include/__locale b/libcxx/include/__locale
index b675e01bac..85e99cb367 100644
--- a/libcxx/include/__locale
+++ b/libcxx/include/__locale
@@ -314,7 +314,7 @@ public:
 #  else
   static const mask __regex_word = 1 << 10;
 #  endif // defined(__BIONIC__)
-#elif defined(__GLIBC__)
+#elif defined(__GLIBC__) || defined(__crescent__)
   typedef unsigned short mask;
   static const mask space  = _ISspace;
   static const mask print  = _ISprint;
@@ -326,7 +326,7 @@ public:
   static const mask punct  = _ISpunct;
   static const mask xdigit = _ISxdigit;
   static const mask blank  = _ISblank;
-#  if defined(__mips__) || (BYTE_ORDER == BIG_ENDIAN)
+#  if (defined(__mips__) || (BYTE_ORDER == BIG_ENDIAN)) && !defined(__crescent__)
   static const mask __regex_word = static_cast<mask>(_ISbit(15));
 #  else
   static const mask __regex_word = 0x80;
@@ -526,6 +526,11 @@ public:
 
   explicit ctype(const mask* __tab = nullptr, bool __del = false, size_t __refs = 0);
 
+#ifndef isascii
+#define isascii(c) (c >= 0 && c <= 127)
+#define __UNDEF_ISASCII
+#endif
+
   _LIBCPP_HIDE_FROM_ABI bool is(mask __m, char_type __c) const {
     return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) != 0 : false;
   }
@@ -550,6 +555,11 @@ public:
     return __low;
   }
 
+#ifdef __UNDEF_ISASCII
+#undef isascii
+#undef __UNDEF_ISASCII
+#endif
+
   _LIBCPP_HIDE_FROM_ABI char_type toupper(char_type __c) const { return do_toupper(__c); }
 
   _LIBCPP_HIDE_FROM_ABI const char_type* toupper(char_type* __low, const char_type* __high) const {
@@ -584,7 +594,7 @@ public:
 #endif
   _LIBCPP_HIDE_FROM_ABI const mask* table() const _NOEXCEPT { return __tab_; }
   static const mask* classic_table() _NOEXCEPT;
-#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)
+#if defined(__GLIBC__) || defined(__EMSCRIPTEN__) || defined(__crescent__)
   static const int* __classic_upper_table() _NOEXCEPT;
   static const int* __classic_lower_table() _NOEXCEPT;
 #endif
diff --git a/libcxx/include/__locale_dir/locale_base_api.h b/libcxx/include/__locale_dir/locale_base_api.h
index 8ed4c29cb8..9d6a6afcf0 100644
--- a/libcxx/include/__locale_dir/locale_base_api.h
+++ b/libcxx/include/__locale_dir/locale_base_api.h
@@ -120,6 +120,8 @@
 
 #  ifdef _LIBCPP_LOCALE__L_EXTENSIONS
 #    include <__locale_dir/locale_base_api/bsd_locale_defaults.h>
+#  elif defined(__crescent__)
+#    include <__locale_dir/locale_base_api/crescent.h>
 #  else
 #    include <__locale_dir/locale_base_api/bsd_locale_fallbacks.h>
 #  endif
@@ -139,15 +141,24 @@ namespace __locale {
 //
 using __locale_t = locale_t;
 
-#  ifndef _LIBCPP_MSVCRT_LIKE
+#  if !defined(_LIBCPP_MSVCRT_LIKE) && !defined(__crescent__)
 inline _LIBCPP_HIDE_FROM_ABI __locale_t __uselocale(__locale_t __loc) { return uselocale(__loc); }
 #  endif
 
 inline _LIBCPP_HIDE_FROM_ABI __locale_t __newlocale(int __category_mask, const char* __name, __locale_t __loc) {
+#ifdef __crescent__
+  return {};
+#else
   return newlocale(__category_mask, __name, __loc);
+#endif
 }
 
-inline _LIBCPP_HIDE_FROM_ABI void __freelocale(__locale_t __loc) { freelocale(__loc); }
+inline _LIBCPP_HIDE_FROM_ABI void __freelocale(__locale_t __loc) {
+#ifdef __crescent__
+#else
+  freelocale(__loc);
+#endif
+}
 
 inline _LIBCPP_HIDE_FROM_ABI lconv* __localeconv(__locale_t& __loc) { return __libcpp_localeconv_l(__loc); }
 
@@ -178,18 +189,30 @@ __strtoull(const char* __nptr, char** __endptr, int __base, __locale_t __loc) {
 //
 // Character manipulation functions
 //
-inline _LIBCPP_HIDE_FROM_ABI int __islower(int __ch, __locale_t __loc) { return islower_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __isupper(int __ch, __locale_t __loc) { return isupper_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __isdigit(int __ch, __locale_t __loc) { return isdigit_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __isxdigit(int __ch, __locale_t __loc) { return isxdigit_l(__ch, __loc); }
+inline _LIBCPP_HIDE_FROM_ABI int __islower(int __ch, __locale_t __loc) {
+  return islower_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __isupper(int __ch, __locale_t __loc) {
+  return isupper_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __isdigit(int __ch, __locale_t __loc) {
+  return isdigit_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __isxdigit(int __ch, __locale_t __loc) {
+  return isxdigit_l(__ch, __loc);
+}
 inline _LIBCPP_HIDE_FROM_ABI int __strcoll(const char* __s1, const char* __s2, __locale_t __loc) {
   return strcoll_l(__s1, __s2, __loc);
 }
 inline _LIBCPP_HIDE_FROM_ABI size_t __strxfrm(char* __dest, const char* __src, size_t __n, __locale_t __loc) {
   return strxfrm_l(__dest, __src, __n, __loc);
 }
-inline _LIBCPP_HIDE_FROM_ABI int __toupper(int __ch, __locale_t __loc) { return toupper_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __tolower(int __ch, __locale_t __loc) { return tolower_l(__ch, __loc); }
+inline _LIBCPP_HIDE_FROM_ABI int __toupper(int __ch, __locale_t __loc) {
+  return toupper_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __tolower(int __ch, __locale_t __loc) {
+  return tolower_l(__ch, __loc);
+}
 
 #  if _LIBCPP_HAS_WIDE_CHARACTERS
 inline _LIBCPP_HIDE_FROM_ABI int __wcscoll(const wchar_t* __s1, const wchar_t* __s2, __locale_t __loc) {
@@ -198,18 +221,42 @@ inline _LIBCPP_HIDE_FROM_ABI int __wcscoll(const wchar_t* __s1, const wchar_t* _
 inline _LIBCPP_HIDE_FROM_ABI size_t __wcsxfrm(wchar_t* __dest, const wchar_t* __src, size_t __n, __locale_t __loc) {
   return wcsxfrm_l(__dest, __src, __n, __loc);
 }
-inline _LIBCPP_HIDE_FROM_ABI int __iswspace(wint_t __ch, __locale_t __loc) { return iswspace_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswprint(wint_t __ch, __locale_t __loc) { return iswprint_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswcntrl(wint_t __ch, __locale_t __loc) { return iswcntrl_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswupper(wint_t __ch, __locale_t __loc) { return iswupper_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswlower(wint_t __ch, __locale_t __loc) { return iswlower_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswalpha(wint_t __ch, __locale_t __loc) { return iswalpha_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswblank(wint_t __ch, __locale_t __loc) { return iswblank_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswdigit(wint_t __ch, __locale_t __loc) { return iswdigit_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswpunct(wint_t __ch, __locale_t __loc) { return iswpunct_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI int __iswxdigit(wint_t __ch, __locale_t __loc) { return iswxdigit_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI wint_t __towupper(wint_t __ch, __locale_t __loc) { return towupper_l(__ch, __loc); }
-inline _LIBCPP_HIDE_FROM_ABI wint_t __towlower(wint_t __ch, __locale_t __loc) { return towlower_l(__ch, __loc); }
+inline _LIBCPP_HIDE_FROM_ABI int __iswspace(wint_t __ch, __locale_t __loc) {
+  return iswspace_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswprint(wint_t __ch, __locale_t __loc) {
+  return iswprint_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswcntrl(wint_t __ch, __locale_t __loc) {
+  return iswcntrl_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswupper(wint_t __ch, __locale_t __loc) {
+  return iswupper_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswlower(wint_t __ch, __locale_t __loc) {
+  return iswlower_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswalpha(wint_t __ch, __locale_t __loc) {
+  return iswalpha_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswblank(wint_t __ch, __locale_t __loc) {
+  return iswblank_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswdigit(wint_t __ch, __locale_t __loc) {
+  return iswdigit_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswpunct(wint_t __ch, __locale_t __loc) {
+  return iswpunct_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI int __iswxdigit(wint_t __ch, __locale_t __loc) {
+  return iswxdigit_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI wint_t __towupper(wint_t __ch, __locale_t __loc) {
+  return towupper_l(__ch, __loc);
+}
+inline _LIBCPP_HIDE_FROM_ABI wint_t __towlower(wint_t __ch, __locale_t __loc) {
+  return towlower_l(__ch, __loc);
+}
 #  endif
 
 inline _LIBCPP_HIDE_FROM_ABI size_t
diff --git a/libcxx/include/__locale_dir/locale_base_api/crescent.h b/libcxx/include/__locale_dir/locale_base_api/crescent.h
new file mode 100644
index 0000000000..4aa74c5e52
--- /dev/null
+++ b/libcxx/include/__locale_dir/locale_base_api/crescent.h
@@ -0,0 +1,169 @@
+// -*- C++ -*-
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+
+#ifndef _LIBCPP___LOCALE_DIR_LOCALE_BASE_API_CRESCENT_H
+#define _LIBCPP___LOCALE_DIR_LOCALE_BASE_API_CRESCENT_H
+
+#include <locale.h>
+
+#include <__locale_dir/locale_guard.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if _LIBCPP_HAS_WIDE_CHARACTERS
+#  include <cwchar>
+#endif
+
+#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
+#  pragma GCC system_header
+#endif
+
+int __libcpp_vasprintf(char** sptr, const char* __restrict format, va_list ap);
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+inline _LIBCPP_HIDE_FROM_ABI decltype(MB_CUR_MAX) __libcpp_mb_cur_max_l(locale_t __l) {
+  __locale_guard __current(__l);
+  return MB_CUR_MAX;
+}
+
+long long strtoll_l(const char* __nptr, char** __endptr, int __base, locale_t __loc);
+unsigned long long strtoull_l(const char* __nptr, char** __endptr, int __base, locale_t __loc);
+
+float strtof_l(const char* __nptr, char** __endptr, locale_t __loc);
+double strtod_l(const char* __nptr, char** __endptr, locale_t __loc);
+long double strtold_l(const char* __nptr, char** __endptr, locale_t __loc);
+
+int islower_l(int, locale_t);
+int isupper_l(int, locale_t);
+int isdigit_l(int, locale_t);
+int isxdigit_l(int, locale_t);
+int strcoll_l(const char*, const char*, __locale_t);
+size_t strxfrm_l(char*, const char*, size_t, __locale_t);
+int toupper_l(int, __locale_t);
+int tolower_l(int, __locale_t);
+
+int wcscoll_l(const wchar_t* __s1, const wchar_t* __s2, __locale_t __loc);
+size_t wcsxfrm_l(wchar_t*, const wchar_t*, size_t, __locale_t);
+int iswspace_l(wint_t, __locale_t);
+int iswprint_l(wint_t, __locale_t);
+int iswcntrl_l(wint_t, __locale_t);
+int iswupper_l(wint_t, __locale_t);
+int iswlower_l(wint_t, __locale_t);
+int iswalpha_l(wint_t, __locale_t);
+int iswblank_l(wint_t, __locale_t);
+int iswdigit_l(wint_t, __locale_t);
+int iswpunct_l(wint_t, __locale_t);
+int iswxdigit_l(wint_t, __locale_t);
+wint_t towupper_l(wint_t, __locale_t);
+wint_t towlower_l(wint_t, __locale_t);
+
+size_t strftime_l(char*, size_t, const char*, const tm*, __locale_t);
+
+#if _LIBCPP_HAS_WIDE_CHARACTERS
+inline _LIBCPP_HIDE_FROM_ABI wint_t __libcpp_btowc_l(int __c, locale_t __l) {
+  __locale_guard __current(__l);
+  return btowc(__c);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI int __libcpp_wctob_l(wint_t __c, locale_t __l) {
+  __locale_guard __current(__l);
+  return wctob(__c);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI size_t
+__libcpp_wcsnrtombs_l(char* __dest, const wchar_t** __src, size_t __nwc, size_t __len, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  size_t wcsnrtombs(char* __restrict dst,
+                  const wchar_t** __restrict src,
+                  size_t max_source_chars,
+                  size_t dst_size_bytes,
+                  mbstate_t* __restrict ps);
+  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI size_t __libcpp_wcrtomb_l(char* __s, wchar_t __wc, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  return wcrtomb(__s, __wc, __ps);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI size_t
+__libcpp_mbsnrtowcs_l(wchar_t* __dest, const char** __src, size_t __nms, size_t __len, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  size_t mbsnrtowcs(wchar_t* __restrict dst,
+                  const char** __restrict src,
+                  size_t src_size_bytes,
+                  size_t max_dest_chars,
+                  mbstate_t* __restrict ps);
+  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI size_t
+__libcpp_mbrtowc_l(wchar_t* __pwc, const char* __s, size_t __n, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  return mbrtowc(__pwc, __s, __n, __ps);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI int __libcpp_mbtowc_l(wchar_t* __pwc, const char* __pmb, size_t __max, locale_t __l) {
+  __locale_guard __current(__l);
+  return mbtowc(__pwc, __pmb, __max);
+}
+
+inline _LIBCPP_HIDE_FROM_ABI size_t __libcpp_mbrlen_l(const char* __s, size_t __n, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  return mbrlen(__s, __n, __ps);
+}
+#endif // _LIBCPP_HAS_WIDE_CHARACTERS
+
+inline _LIBCPP_HIDE_FROM_ABI lconv* __libcpp_localeconv_l(locale_t& __l) {
+  __locale_guard __current(__l);
+  return localeconv();
+}
+
+#if _LIBCPP_HAS_WIDE_CHARACTERS
+inline _LIBCPP_HIDE_FROM_ABI size_t
+__libcpp_mbsrtowcs_l(wchar_t* __dest, const char** __src, size_t __len, mbstate_t* __ps, locale_t __l) {
+  __locale_guard __current(__l);
+  return mbsrtowcs(__dest, __src, __len, __ps);
+}
+#endif
+
+inline _LIBCPP_ATTRIBUTE_FORMAT(__printf__, 4, 5) int __libcpp_snprintf_l(
+    char* __s, size_t __n, locale_t __l, const char* __format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+  __locale_guard __current(__l);
+  int __res = vsnprintf(__s, __n, __format, __va);
+  va_end(__va);
+  return __res;
+}
+
+inline _LIBCPP_ATTRIBUTE_FORMAT(__printf__, 3, 4) int __libcpp_asprintf_l(
+    char** __s, locale_t __l, const char* __format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+  __locale_guard __current(__l);
+  int __res = __libcpp_vasprintf(__s, __format, __va);
+  va_end(__va);
+  return __res;
+}
+
+inline _LIBCPP_ATTRIBUTE_FORMAT(__scanf__, 3, 4) int __libcpp_sscanf_l(
+    const char* __s, locale_t __l, const char* __format, ...) {
+  va_list __va;
+  va_start(__va, __format);
+  __locale_guard __current(__l);
+  int __res = vsscanf(__s, __format, __va);
+  va_end(__va);
+  return __res;
+}
+
+_LIBCPP_END_NAMESPACE_STD
+
+#endif // _LIBCPP___LOCALE_DIR_LOCALE_BASE_API_CRESCENT_H
diff --git a/libcxx/include/__locale_dir/locale_guard.h b/libcxx/include/__locale_dir/locale_guard.h
index e0c414c001..b9d1dff5a5 100644
--- a/libcxx/include/__locale_dir/locale_guard.h
+++ b/libcxx/include/__locale_dir/locale_guard.h
@@ -57,6 +57,12 @@ struct __locale_guard {
   int __status;
   char* __locale_all = nullptr;
 };
+#elif defined(__crescent__)
+struct __locale_guard {
+  _LIBCPP_HIDE_FROM_ABI __locale_guard(locale_t __l) {}
+
+  _LIBCPP_HIDE_FROM_ABI ~__locale_guard() {}
+};
 #else
 struct __locale_guard {
   _LIBCPP_HIDE_FROM_ABI __locale_guard(locale_t& __loc) : __old_loc_(uselocale(__loc)) {}
diff --git a/libcxx/include/fstream b/libcxx/include/fstream
index e188bfc904..8a43dd04b8 100644
--- a/libcxx/include/fstream
+++ b/libcxx/include/fstream
@@ -213,7 +213,7 @@ typedef basic_fstream<wchar_t> wfstream;
 _LIBCPP_PUSH_MACROS
 #include <__undef_macros>
 
-#if !defined(_LIBCPP_MSVCRT) && !defined(_NEWLIB_VERSION)
+#if !defined(_LIBCPP_MSVCRT) && !defined(_NEWLIB_VERSION) && !defined(__crescent__)
 #  define _LIBCPP_HAS_OFF_T_FUNCTIONS 1
 #else
 #  define _LIBCPP_HAS_OFF_T_FUNCTIONS 0
@@ -700,6 +700,9 @@ basic_filebuf<_CharT, _Traits>* basic_filebuf<_CharT, _Traits>::open(const char*
 
 template <class _CharT, class _Traits>
 inline basic_filebuf<_CharT, _Traits>* basic_filebuf<_CharT, _Traits>::__open(int __fd, ios_base::openmode __mode) {
+#ifdef __crescent__
+  return nullptr;
+#else 
   if (__file_)
     return nullptr;
   const char* __mdstr = __make_mdstring(__mode);
@@ -707,6 +710,7 @@ inline basic_filebuf<_CharT, _Traits>* basic_filebuf<_CharT, _Traits>::__open(in
     return nullptr;
 
   return __do_open(fdopen(__fd, __mdstr), __mode);
+#endif
 }
 
 #  if _LIBCPP_HAS_OPEN_WITH_WCHAR
diff --git a/libcxx/include/print b/libcxx/include/print
index 8a8b686d18..c2a97fc992 100644
--- a/libcxx/include/print
+++ b/libcxx/include/print
@@ -205,6 +205,9 @@ _LIBCPP_HIDE_FROM_ABI inline bool __is_terminal([[maybe_unused]] FILE* __stream)
   return std::__is_windows_terminal(__stream);
 #  elif __has_include(<unistd.h>)
   return std::__is_posix_terminal(__stream);
+#  elif defined(__crescent__)
+  // todo
+  return true;
 #  else
 #    error "Provide a way to determine whether a FILE* is a terminal"
 #  endif
diff --git a/libcxx/src/CMakeLists.txt b/libcxx/src/CMakeLists.txt
index cce8b8976f..66d60cc2ea 100644
--- a/libcxx/src/CMakeLists.txt
+++ b/libcxx/src/CMakeLists.txt
@@ -118,6 +118,12 @@ elseif(ZOS)
     )
 endif()
 
+# todo
+list(APPEND LIBCXX_SOURCES
+  support/crescent/locale_crescent.cpp
+  support/crescent/support.cpp
+)
+
 if (LIBCXX_ENABLE_FILESYSTEM)
   list(APPEND LIBCXX_SOURCES
     filesystem/directory_entry.cpp
diff --git a/libcxx/src/chrono.cpp b/libcxx/src/chrono.cpp
index 35105693b9..b425096073 100644
--- a/libcxx/src/chrono.cpp
+++ b/libcxx/src/chrono.cpp
@@ -124,6 +124,13 @@ static system_clock::time_point __libcpp_system_clock_now() {
   return system_clock::time_point(seconds(tp.tv_sec) + microseconds(tp.tv_nsec / 1000));
 }
 
+#elif defined(__crescent__)
+
+static system_clock::time_point __libcpp_system_clock_now() {
+  // todo
+  return system_clock::time_point();
+}
+
 #else
 
 static system_clock::time_point __libcpp_system_clock_now() {
@@ -225,6 +232,17 @@ static steady_clock::time_point __libcpp_steady_clock_now() {
   return steady_clock::time_point(seconds(tp.tv_sec) + nanoseconds(tp.tv_nsec));
 }
 
+#  elif defined(__crescent__)
+
+#include <crescent/syscall.h>
+#include <crescent/syscalls.h>
+
+static steady_clock::time_point __libcpp_steady_clock_now() {
+  uint64_t us;
+  syscall(SYS_GET_TIME, &us);
+  return steady_clock::time_point(microseconds(us));
+}
+
 #  else
 #    error "Monotonic clock not implemented on this platform"
 #  endif
diff --git a/libcxx/src/experimental/tzdb.cpp b/libcxx/src/experimental/tzdb.cpp
index d22de21c99..9e77b7dc6a 100644
--- a/libcxx/src/experimental/tzdb.cpp
+++ b/libcxx/src/experimental/tzdb.cpp
@@ -48,7 +48,7 @@ namespace chrono {
 // This function is weak so it can be overriden in the tests. The
 // declaration is in the test header test/support/test_tzdb.h
 _LIBCPP_WEAK string_view __libcpp_tzdb_directory() {
-#if defined(__linux__)
+#if defined(__linux__) || defined(__crescent__)
   return "/usr/share/zoneinfo/";
 #else
 #  error "unknown path to the IANA Time Zone Database"
diff --git a/libcxx/src/filesystem/file_descriptor.h b/libcxx/src/filesystem/file_descriptor.h
index db66ad55bd..35a47cb6e7 100644
--- a/libcxx/src/filesystem/file_descriptor.h
+++ b/libcxx/src/filesystem/file_descriptor.h
@@ -24,6 +24,7 @@
 #  define WIN32_LEAN_AND_MEAN
 #  define NOMINMAX
 #  include <windows.h>
+#elif defined(__crescent__)
 #else
 #  include <dirent.h> // for DIR & friends
 #  include <fcntl.h>  // values for fchmodat
diff --git a/libcxx/src/filesystem/filesystem_clock.cpp b/libcxx/src/filesystem/filesystem_clock.cpp
index d174ecdc9e..e75431b98e 100644
--- a/libcxx/src/filesystem/filesystem_clock.cpp
+++ b/libcxx/src/filesystem/filesystem_clock.cpp
@@ -50,6 +50,9 @@ _FilesystemClock::time_point _FilesystemClock::now() noexcept {
   GetSystemTimeAsFileTime(&time);
   detail::TimeSpec tp = detail::filetime_to_timespec(time);
   return time_point(__secs(tp.tv_sec) + chrono::duration_cast<duration>(__nsecs(tp.tv_nsec)));
+#elif defined(__crescent__)
+  // todo
+  return time_point();
 #elif defined(_LIBCPP_HAS_CLOCK_GETTIME)
   typedef chrono::duration<rep, nano> __nsecs;
   struct timespec tp;
diff --git a/libcxx/src/filesystem/posix_compat.h b/libcxx/src/filesystem/posix_compat.h
index b41c004341..9df4168467 100644
--- a/libcxx/src/filesystem/posix_compat.h
+++ b/libcxx/src/filesystem/posix_compat.h
@@ -36,6 +36,7 @@
 #  include <io.h>
 #  include <windows.h>
 #  include <winioctl.h>
+#elif defined(__crescent__)
 #else
 #  include <fcntl.h>
 #  include <sys/stat.h>
@@ -460,6 +461,8 @@ inline SSizeT readlink(const wchar_t* path, wchar_t* ret_buf, size_t bufsize) {
   return name_length / sizeof(wchar_t);
 }
 
+#elif defined(__crescent__)
+
 #else
 inline int symlink_file(const char* oldname, const char* newname) { return ::symlink(oldname, newname); }
 inline int symlink_dir(const char* oldname, const char* newname) { return ::symlink(oldname, newname); }
diff --git a/libcxx/src/filesystem/time_utils.h b/libcxx/src/filesystem/time_utils.h
index 89352e5bd6..6363271216 100644
--- a/libcxx/src/filesystem/time_utils.h
+++ b/libcxx/src/filesystem/time_utils.h
@@ -26,6 +26,7 @@
 #  define WIN32_LEAN_AND_MEAN
 #  define NOMINMAX
 #  include <windows.h>
+#elif defined(__crescent__)
 #else
 #  include <fcntl.h>
 #  include <sys/stat.h>
@@ -97,6 +98,8 @@ inline FILETIME timespec_to_filetime(TimeSpec ts) {
   return ft;
 }
 
+#elif defined(__crescent__)
+
 #else
 using TimeSpec = struct timespec;
 using TimeVal  = struct timeval;
diff --git a/libcxx/src/include/config_elast.h b/libcxx/src/include/config_elast.h
index 7edff2d937..0a2d98b023 100644
--- a/libcxx/src/include/config_elast.h
+++ b/libcxx/src/include/config_elast.h
@@ -29,6 +29,8 @@
 // No _LIBCPP_ELAST needed on NuttX
 #elif defined(__Fuchsia__)
 // No _LIBCPP_ELAST needed on Fuchsia
+#elif defined(__crescent__)
+// No _LIBCPP_ELAST needed on Crescent
 #elif defined(__wasi__)
 // No _LIBCPP_ELAST needed on WASI
 #elif defined(__EMSCRIPTEN__)
diff --git a/libcxx/src/locale.cpp b/libcxx/src/locale.cpp
index a1e10401f0..4cdda04511 100644
--- a/libcxx/src/locale.cpp
+++ b/libcxx/src/locale.cpp
@@ -38,6 +38,10 @@
 #  include <langinfo.h>
 #endif
 
+#if !defined(isascii)
+#define isascii(c) (c >= 0 && c <= 127)
+#endif
+
 #include "include/atomic_support.h"
 #include "include/sso_allocator.h"
 
@@ -895,7 +899,7 @@ extern "C" const int** __ctype_tolower_loc();
 extern "C" const int** __ctype_toupper_loc();
 #endif
 
-#ifdef _LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE
+#if defined(_LIBCPP_PROVIDES_DEFAULT_RUNE_TABLE) || defined(__crescent__)
 const ctype<char>::mask* ctype<char>::classic_table() noexcept {
   // clang-format off
     static constexpr const ctype<char>::mask builtin_table[table_size] = {
@@ -1009,7 +1013,7 @@ const ctype<char>::mask* ctype<char>::classic_table() noexcept {
 }
 #endif
 
-#if defined(__GLIBC__)
+#if defined(__GLIBC__) || defined(__crescent__)
 const int* ctype<char>::__classic_lower_table() noexcept { return _LIBCPP_GET_C_LOCALE->__ctype_tolower; }
 
 const int* ctype<char>::__classic_upper_table() noexcept { return _LIBCPP_GET_C_LOCALE->__ctype_toupper; }
diff --git a/libcxx/src/random.cpp b/libcxx/src/random.cpp
index 3830e3918d..b70c24d8c3 100644
--- a/libcxx/src/random.cpp
+++ b/libcxx/src/random.cpp
@@ -23,6 +23,7 @@
 
 #if defined(_LIBCPP_USING_GETENTROPY)
 #  include <sys/random.h>
+#elif defined(__crescent__)
 #elif defined(_LIBCPP_USING_DEV_RANDOM)
 #  include <fcntl.h>
 #  include <unistd.h>
@@ -64,6 +65,17 @@ random_device::~random_device() {}
 
 unsigned random_device::operator()() { return arc4random(); }
 
+#elif defined(__crescent__)
+
+random_device::random_device(const string&) {}
+
+random_device::~random_device() {}
+
+unsigned random_device::operator()() {
+  // todo
+  return rand();
+}
+
 #elif defined(_LIBCPP_USING_DEV_RANDOM)
 
 random_device::random_device(const string& __token) : __f_(open(__token.c_str(), O_RDONLY)) {
diff --git a/libcxx/src/support/crescent/locale_crescent.cpp b/libcxx/src/support/crescent/locale_crescent.cpp
new file mode 100644
index 0000000000..84a8685745
--- /dev/null
+++ b/libcxx/src/support/crescent/locale_crescent.cpp
@@ -0,0 +1,275 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include <cstdarg> // va_start, va_end
+#include <cwchar>
+#include <locale>
+#include <memory>
+#include <type_traits>
+
+#include <__locale_dir/locale_guard.h>
+
+int __libcpp_vasprintf(char** sptr, const char* __restrict fmt, va_list ap);
+
+decltype(MB_CUR_MAX) MB_CUR_MAX_L(locale_t __l) {
+#if defined(_LIBCPP_MSVCRT)
+  return ___mb_cur_max_l_func(__l);
+#else
+  std::__locale_guard __current(__l);
+  return MB_CUR_MAX;
+#endif
+}
+
+lconv* localeconv_l(locale_t& loc) {
+  std::__locale_guard __current(loc);
+  lconv* lc = localeconv();
+  if (!lc)
+    return lc;
+  return lc;
+}
+size_t mbrlen_l(const char* __restrict s, size_t n, mbstate_t* __restrict ps, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return mbrlen(s, n, ps);
+}
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+size_t mbsnrtowcs(wchar_t* __restrict dst,
+                  const char** __restrict src,
+                  size_t src_size_bytes,
+                  size_t max_dest_chars,
+                  mbstate_t* __restrict ps);
+
+size_t wcsnrtombs(char* __restrict dst,
+                  const wchar_t** __restrict src,
+                  size_t max_source_chars,
+                  size_t dst_size_bytes,
+                  mbstate_t* __restrict ps);
+
+_LIBCPP_END_NAMESPACE_STD
+
+using std::mbsrtowcs;
+using std::mbsnrtowcs;
+using std::wcsnrtombs;
+
+size_t
+mbsrtowcs_l(wchar_t* __restrict dst, const char** __restrict src, size_t len, mbstate_t* __restrict ps, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return mbsrtowcs(dst, src, len, ps);
+}
+size_t wcrtomb_l(char* __restrict s, wchar_t wc, mbstate_t* __restrict ps, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return wcrtomb(s, wc, ps);
+}
+size_t mbrtowc_l(wchar_t* __restrict pwc, const char* __restrict s, size_t n, mbstate_t* __restrict ps, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return mbrtowc(pwc, s, n, ps);
+}
+size_t mbsnrtowcs_l(wchar_t* __restrict dst,
+                    const char** __restrict src,
+                    size_t nms,
+                    size_t len,
+                    mbstate_t* __restrict ps,
+                    locale_t loc) {
+  std::__locale_guard __current(loc);
+  return mbsnrtowcs(dst, src, nms, len, ps);
+}
+
+size_t wcsnrtombs_l(char* __restrict dst,
+                    const wchar_t** __restrict src,
+                    size_t nwc,
+                    size_t len,
+                    mbstate_t* __restrict ps,
+                    locale_t loc) {
+  std::__locale_guard __current(loc);
+  return wcsnrtombs(dst, src, nwc, len, ps);
+}
+wint_t btowc_l(int c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return btowc(c);
+}
+int wctob_l(wint_t c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return wctob(c);
+}
+
+int snprintf_l(char* ret, size_t n, locale_t loc, const char* format, ...) {
+  va_list ap;
+  va_start(ap, format);
+#if defined(_LIBCPP_MSVCRT)
+  // FIXME: Remove usage of internal CRT function and globals.
+  int result = __stdio_common_vsprintf(
+      _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR, ret, n, format, loc, ap);
+#else
+  std::__locale_guard __current(loc);
+  _LIBCPP_DIAGNOSTIC_PUSH
+  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
+  int result = vsnprintf(ret, n, format, ap);
+  _LIBCPP_DIAGNOSTIC_POP
+#endif
+  va_end(ap);
+  return result;
+}
+
+int vasprintf_l(char** ret, locale_t loc, const char* format, va_list ap);
+
+int asprintf_l(char** ret, locale_t loc, const char* format, ...) {
+  va_list ap;
+  va_start(ap, format);
+  int result = vasprintf_l(ret, loc, format, ap);
+  va_end(ap);
+  return result;
+}
+int vasprintf_l(char** ret, locale_t loc, const char* format, va_list ap) {
+  std::__locale_guard __current(loc);
+  return __libcpp_vasprintf(ret, format, ap);
+}
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+float strtof_l(const char* nptr, char** endptr, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strtof(nptr, endptr);
+}
+
+double strtod_l(const char* nptr, char** endptr, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strtod(nptr, endptr);
+}
+
+long double strtold_l(const char* nptr, char** endptr, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strtold(nptr, endptr);
+}
+
+long long strtoll_l(const char* nptr, char** endptr, int base, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strtoll(nptr, endptr, base);
+}
+
+unsigned long long strtoull_l(const char* nptr, char** endptr, int base, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strtoull(nptr, endptr, base);
+}
+
+int islower_l(int c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return islower(c);
+}
+
+int isupper_l(int c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return isupper(c);
+}
+
+int isdigit_l(int c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return isdigit(c);
+}
+
+int isxdigit_l(int c, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return isxdigit(c);
+}
+
+int strcoll_l(const char* s1, const char* s2, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strcoll(s1, s2);
+}
+
+size_t strxfrm_l(char* dest, const char* src, size_t n, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strxfrm(dest, src, n);
+}
+
+int toupper_l(int c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return toupper(c);
+}
+
+int tolower_l(int c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return tolower(c);
+}
+
+int wcscoll_l(const wchar_t* s1, const wchar_t* s2, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return wcscoll(s1, s2);
+}
+
+size_t wcsxfrm_l(wchar_t* dest, const wchar_t* src, size_t n, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return wcsxfrm(dest, src, n);
+}
+
+int iswspace_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswspace(c);
+}
+
+int iswprint_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswprint(c);
+}
+
+int iswcntrl_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswcntrl(c);
+}
+
+int iswupper_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswupper(c);
+}
+
+int iswlower_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswlower(c);
+}
+
+int iswalpha_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswalpha(c);
+}
+
+int iswblank_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswblank(c);
+}
+
+int iswdigit_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswdigit(c);
+}
+
+int iswpunct_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswpunct(c);
+}
+
+int iswxdigit_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return iswxdigit(c);
+}
+
+wint_t towupper_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return towupper(c);
+}
+
+wint_t towlower_l(wint_t c, __locale_t loc) {
+  std::__locale_guard __current(loc);
+  return towlower(c);
+}
+
+size_t strftime_l(char* ret, size_t n, const char* format, const struct tm* tm, locale_t loc) {
+  std::__locale_guard __current(loc);
+  return strftime(ret, n, format, tm);
+}
+
+_LIBCPP_END_NAMESPACE_STD
diff --git a/libcxx/src/support/crescent/support.cpp b/libcxx/src/support/crescent/support.cpp
new file mode 100644
index 0000000000..51ed3baf47
--- /dev/null
+++ b/libcxx/src/support/crescent/support.cpp
@@ -0,0 +1,190 @@
+//===----------------------------------------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include <cstdarg> // va_start, va_end
+#include <cstddef> // size_t
+#include <cstdio>  // vsprintf, vsnprintf
+#include <cstdlib> // malloc
+#include <cstring> // strcpy, wcsncpy
+#include <cwchar>  // mbstate_t
+#include <cerrno>
+#include <locale>
+
+// Like sprintf, but when return value >= 0 it returns
+// a pointer to a malloc'd string in *sptr.
+// If return >= 0, use free to delete *sptr.
+int __libcpp_vasprintf(char** sptr, const char* __restrict format, va_list ap) {
+  *sptr = nullptr;
+  // Query the count required.
+  va_list ap_copy;
+  va_copy(ap_copy, ap);
+  _LIBCPP_DIAGNOSTIC_PUSH
+  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
+  int count = vsnprintf(nullptr, 0, format, ap_copy);
+  _LIBCPP_DIAGNOSTIC_POP
+  va_end(ap_copy);
+  if (count < 0)
+    return count;
+  size_t buffer_size = static_cast<size_t>(count) + 1;
+  char* p            = static_cast<char*>(malloc(buffer_size));
+  if (!p)
+    return -1;
+  // If we haven't used exactly what was required, something is wrong.
+  // Maybe bug in vsnprintf. Report the error and return.
+  _LIBCPP_DIAGNOSTIC_PUSH
+  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
+  if (vsnprintf(p, buffer_size, format, ap) != count) {
+    _LIBCPP_DIAGNOSTIC_POP
+    free(p);
+    return -1;
+  }
+  // All good. This is returning memory to the caller not freeing it.
+  *sptr = p;
+  return count;
+}
+
+_LIBCPP_BEGIN_NAMESPACE_STD
+
+// Returns >= 0: the number of wide characters found in the
+// multi byte sequence src (of src_size_bytes), that fit in the buffer dst
+// (of max_dest_chars elements size). The count returned excludes the
+// null terminator. When dst is NULL, no characters are copied
+// and no "out" parameters are updated.
+// Returns (size_t) -1: an incomplete sequence encountered.
+// Leaves *src pointing the next character to convert or NULL
+// if a null character was converted from *src.
+size_t mbsnrtowcs(wchar_t* __restrict dst,
+                  const char** __restrict src,
+                  size_t src_size_bytes,
+                  size_t max_dest_chars,
+                  mbstate_t* __restrict ps) {
+  const size_t terminated_sequence = static_cast<size_t>(0);
+  // const size_t invalid_sequence = static_cast<size_t>(-1);
+  const size_t incomplete_sequence = static_cast< size_t>(-2);
+
+  size_t dest_converted   = 0;
+  size_t source_converted = 0;
+  size_t source_remaining = src_size_bytes;
+  size_t result           = 0;
+  bool have_result        = false;
+
+  // If dst is null then max_dest_chars should be ignored according to the
+  // standard.  Setting max_dest_chars to a large value has this effect.
+  if (!dst)
+    max_dest_chars = static_cast<size_t>(-1);
+
+  while (source_remaining) {
+    if (dst && dest_converted >= max_dest_chars)
+      break;
+    // Converts one multi byte character.
+    // if result > 0, it's the size in bytes of that character.
+    // othewise if result is zero it indicates the null character has been found.
+    // otherwise it's an error and errno may be set.
+    size_t char_size = mbrtowc(dst ? dst + dest_converted : nullptr, *src + source_converted, source_remaining, ps);
+    // Don't do anything to change errno from here on.
+    if (char_size > 0) {
+      source_remaining -= char_size;
+      source_converted += char_size;
+      ++dest_converted;
+      continue;
+    }
+    result      = char_size;
+    have_result = true;
+    break;
+  }
+  if (dst) {
+    if (have_result && result == terminated_sequence)
+      *src = nullptr;
+    else
+      *src += source_converted;
+  }
+  if (have_result && result != terminated_sequence && result != incomplete_sequence)
+    return static_cast<size_t>(-1);
+
+  return dest_converted;
+}
+
+static int wcrtomb_s(
+  size_t* __restrict ret,
+  char* __restrict s,
+  size_t,
+  wchar_t wc,
+  mbstate_t* __restrict ps) {
+  *ret = wcrtomb(s, wc, ps);
+  return 0;
+}
+
+// Converts max_source_chars from the wide character buffer pointer to by *src,
+// into the multi byte character sequence buffer stored at dst which must be
+// dst_size_bytes bytes in size.
+// Returns >= 0: the number of bytes in the sequence
+// converted from *src, excluding the null terminator.
+// Returns size_t(-1) if an error occurs, also sets errno.
+// If dst is NULL dst_size_bytes is ignored and no bytes are copied to dst
+// and no "out" parameters are updated.
+size_t wcsnrtombs(char* __restrict dst,
+                  const wchar_t** __restrict src,
+                  size_t max_source_chars,
+                  size_t dst_size_bytes,
+                  mbstate_t* __restrict ps) {
+  // const size_t invalid_sequence = static_cast<size_t>(-1);
+
+  size_t source_converted = 0;
+  size_t dest_converted   = 0;
+  size_t dest_remaining   = dst_size_bytes;
+  size_t char_size        = 0;
+  const int no_error  = (int)0;
+  int result          = (int)0;
+  bool have_result        = false;
+  bool terminator_found   = false;
+
+  // If dst is null then dst_size_bytes should be ignored according to the
+  // standard.  Setting dest_remaining to a large value has this effect.
+  if (!dst)
+    dest_remaining = static_cast<size_t>(-1);
+
+  while (source_converted != max_source_chars) {
+    if (!dest_remaining)
+      break;
+    wchar_t c = (*src)[source_converted];
+    if (dst)
+      result = wcrtomb_s(&char_size, dst + dest_converted, dest_remaining, c, ps);
+    else
+      result = wcrtomb_s(&char_size, nullptr, 0, c, ps);
+    // If result is zero there is no error and char_size contains the
+    // size of the multi-byte-sequence converted.
+    // Otherwise result indicates an errno type error.
+    if (result == no_error) {
+      if (c == L'\0') {
+        terminator_found = true;
+        break;
+      }
+      ++source_converted;
+      if (dst)
+        dest_remaining -= char_size;
+      dest_converted += char_size;
+      continue;
+    }
+    have_result = true;
+    break;
+  }
+  if (dst) {
+    if (terminator_found)
+      *src = nullptr;
+    else
+      *src = *src + source_converted;
+  }
+  if (have_result && result != no_error) {
+    errno = result;
+    return static_cast<size_t>(-1);
+  }
+
+  return dest_converted;
+}
+
+_LIBCPP_END_NAMESPACE_STD
diff --git a/libcxx/src/system_error.cpp b/libcxx/src/system_error.cpp
index d555bca995..1aa6bd4e4c 100644
--- a/libcxx/src/system_error.cpp
+++ b/libcxx/src/system_error.cpp
@@ -42,6 +42,11 @@ string do_strerror_r(int ev) {
   std::snprintf(buffer, strerror_buff_size, "unknown error %d", ev);
   return string(buffer);
 }
+#  elif defined(__crescent__)
+string do_strerror_r(int ev) {
+  (void) strerror_buff_size;
+  return ::strerror(ev);
+}
 #  else
 
 // Only one of the two following functions will be used, depending on
-- 
2.45.2

